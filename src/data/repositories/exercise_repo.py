"""Exercise Repository

This module handles storage and retrieval of generated exercises in the database.
It follows the best practices from the docs and integrates with the existing
database structure.

Key Functions:
- save_generated_exercise() -> bool
- get_exercises_by_criteria() -> List[Exercise]
- bulk_save_exercises() -> int
"""

import logging
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

logger = logging.getLogger(__name__)

@dataclass
class Exercise:
    """Exercise data model."""
    id: Optional[str]  # Will be generated by database
    topic_id: str
    source_lang: str
    target_lang: str
    difficulty_level: str
    exercise_type: str
    theory: str
    exercise_introduction: str
    exercise_input: str
    expected_output: str
    media_url: Optional[str] = None
    verification_hash: Optional[str] = None
    created_at: Optional[datetime] = None

class ExerciseRepository:
    """Repository for exercise storage and retrieval."""
    
    def __init__(self, database_url: str = "sqlite:///c:/Users/toni_/OneDrive/Documentos/Scripts/1. General AI Tests/30_Whatsapp_Duolingo/scripts/curriculum.db"):
        """Initialize repository with database connection."""
        self.engine = create_engine(database_url, echo=False)
        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
        
    def create_exercises_table(self):
        """Create exercises table if it doesn't exist."""
        create_table_sql = """
        CREATE TABLE IF NOT EXISTS exercises (
            id TEXT PRIMARY KEY,
            topic_id TEXT NOT NULL,
            source_lang TEXT NOT NULL,
            target_lang TEXT NOT NULL,
            difficulty_level TEXT NOT NULL,
            exercise_type TEXT NOT NULL,
            theory TEXT NOT NULL,
            exercise_introduction TEXT NOT NULL,
            exercise_input TEXT NOT NULL,
            expected_output TEXT NOT NULL,
            media_url TEXT,
            verification_hash TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """
        
        with self.engine.connect() as conn:
            conn.execute(text(create_table_sql))
            conn.commit()
        
        logger.info("Exercises table created/verified")
    
    def save_generated_exercise(self, exercise_data: Dict, curriculum_combo_id: str) -> Optional[str]:
        """Save a single generated exercise to database.
        
        Args:
            exercise_data: Generated exercise data from orchestrator
            curriculum_combo_id: Reference to curriculum combination
            
        Returns:
            Exercise ID if successful, None otherwise
        """
        session = self.SessionLocal()
        try:
            # Generate unique ID
            exercise_id = f"EX_{curriculum_combo_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
            
            # Generate verification hash
            verification_hash = self._generate_verification_hash(exercise_data)
            
            insert_sql = """
            INSERT INTO exercises (
                id, topic_id, source_lang, target_lang, difficulty_level,
                exercise_type, theory, exercise_introduction, exercise_input,
                expected_output, verification_hash
            ) VALUES (
                :id, :topic_id, :source_lang, :target_lang, :difficulty_level,
                :exercise_type, :theory, :exercise_introduction, :exercise_input,
                :expected_output, :verification_hash
            )
            """
            
            session.execute(text(insert_sql), {
                'id': exercise_id,
                'topic_id': exercise_data.get('topic', 'general'),
                'source_lang': exercise_data.get('source_lang'),
                'target_lang': exercise_data.get('target_lang'),
                'difficulty_level': exercise_data.get('difficulty_level'),
                'exercise_type': exercise_data.get('exercise_type'),
                'theory': exercise_data.get('theory'),
                'exercise_introduction': exercise_data.get('exercise_introduction'),
                'exercise_input': exercise_data.get('exercise_input'),
                'expected_output': exercise_data.get('expected_output'),
                'verification_hash': verification_hash
            })
            
            session.commit()
            logger.info(f"Saved exercise: {exercise_id}")
            return exercise_id
            
        except Exception as e:
            session.rollback()
            logger.error(f"Error saving exercise: {e}")
            return None
        finally:
            session.close()
    
    def bulk_save_exercises(self, exercises: List[Dict], curriculum_combo_ids: List[str]) -> int:
        """Save multiple exercises in bulk.
        
        Args:
            exercises: List of exercise data dictionaries
            curriculum_combo_ids: List of corresponding curriculum combo IDs
            
        Returns:
            Number of exercises successfully saved
        """
        if len(exercises) != len(curriculum_combo_ids):
            raise ValueError("Length mismatch between exercises and combo IDs")
        
        successful = 0
        
        for exercise_data, combo_id in zip(exercises, curriculum_combo_ids):
            if self.save_generated_exercise(exercise_data, combo_id):
                successful += 1
        
        logger.info(f"Bulk saved {successful}/{len(exercises)} exercises")
        return successful
    
    def get_exercises_by_criteria(self, 
                                source_lang: Optional[str] = None,
                                target_lang: Optional[str] = None,
                                difficulty_level: Optional[str] = None,
                                exercise_type: Optional[str] = None,
                                topic: Optional[str] = None,
                                limit: int = 50) -> List[Exercise]:
        """Retrieve exercises by filtering criteria.
        
        Args:
            source_lang: Source language filter
            target_lang: Target language filter
            difficulty_level: CEFR level filter
            exercise_type: Exercise type filter
            topic: Topic filter
            limit: Maximum number of exercises to return
            
        Returns:
            List of Exercise objects
        """
        session = self.SessionLocal()
        try:
            # Build WHERE clause dynamically
            conditions = []
            params = {'limit': limit}
            
            if source_lang:
                conditions.append("source_lang = :source_lang")
                params['source_lang'] = source_lang
            
            if target_lang:
                conditions.append("target_lang = :target_lang")
                params['target_lang'] = target_lang
            
            if difficulty_level:
                conditions.append("difficulty_level = :difficulty_level")
                params['difficulty_level'] = difficulty_level
            
            if exercise_type:
                conditions.append("exercise_type = :exercise_type")
                params['exercise_type'] = exercise_type
            
            if topic:
                conditions.append("topic_id = :topic")
                params['topic'] = topic
            
            where_clause = "WHERE " + " AND ".join(conditions) if conditions else ""
            
            query = f"""
                SELECT id, topic_id, source_lang, target_lang, difficulty_level,
                       exercise_type, theory, exercise_introduction, exercise_input,
                       expected_output, media_url, verification_hash, created_at
                FROM exercises
                {where_clause}
                ORDER BY created_at DESC
                LIMIT :limit
            """
            
            result = session.execute(text(query), params)
            
            exercises = []
            for row in result:
                exercise = Exercise(
                    id=row.id,
                    topic_id=row.topic_id,
                    source_lang=row.source_lang,
                    target_lang=row.target_lang,
                    difficulty_level=row.difficulty_level,
                    exercise_type=row.exercise_type,
                    theory=row.theory,
                    exercise_introduction=row.exercise_introduction,
                    exercise_input=row.exercise_input,
                    expected_output=row.expected_output,
                    media_url=row.media_url,
                    verification_hash=row.verification_hash,
                    created_at=row.created_at
                )
                exercises.append(exercise)
            
            return exercises
            
        except Exception as e:
            logger.error(f"Error retrieving exercises: {e}")
            return []
        finally:
            session.close()
    
    def get_random_exercise(self, 
                          source_lang: str,
                          target_lang: str,
                          difficulty_level: str,
                          exclude_ids: Optional[List[str]] = None) -> Optional[Exercise]:
        """Get a random exercise for given criteria.
        
        Args:
            source_lang: Source language
            target_lang: Target language
            difficulty_level: CEFR level
            exclude_ids: List of exercise IDs to exclude
            
        Returns:
            Random Exercise or None if not found
        """
        session = self.SessionLocal()
        try:
            exclude_clause = ""
            params = {
                'source_lang': source_lang,
                'target_lang': target_lang,
                'difficulty_level': difficulty_level
            }
            
            if exclude_ids:
                exclude_clause = "AND id NOT IN :exclude_ids"
                params['exclude_ids'] = tuple(exclude_ids)
            
            query = f"""
                SELECT id, topic_id, source_lang, target_lang, difficulty_level,
                       exercise_type, theory, exercise_introduction, exercise_input,
                       expected_output, media_url, verification_hash, created_at
                FROM exercises
                WHERE source_lang = :source_lang 
                  AND target_lang = :target_lang 
                  AND difficulty_level = :difficulty_level
                  {exclude_clause}
                ORDER BY RANDOM()
                LIMIT 1
            """
            
            result = session.execute(text(query), params)
            row = result.fetchone()
            
            if row:
                return Exercise(
                    id=row.id,
                    topic_id=row.topic_id,
                    source_lang=row.source_lang,
                    target_lang=row.target_lang,
                    difficulty_level=row.difficulty_level,
                    exercise_type=row.exercise_type,
                    theory=row.theory,
                    exercise_introduction=row.exercise_introduction,
                    exercise_input=row.exercise_input,
                    expected_output=row.expected_output,
                    media_url=row.media_url,
                    verification_hash=row.verification_hash,
                    created_at=row.created_at
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting random exercise: {e}")
            return None
        finally:
            session.close()
    
    def get_exercise_statistics(self) -> Dict:
        """Get exercise storage statistics.
        
        Returns:
            Dictionary with statistics
        """
        session = self.SessionLocal()
        try:
            result = session.execute(text("""
                SELECT 
                    COUNT(*) as total_exercises,
                    COUNT(DISTINCT source_lang) as source_languages,
                    COUNT(DISTINCT target_lang) as target_languages,
                    COUNT(DISTINCT difficulty_level) as difficulty_levels,
                    COUNT(DISTINCT exercise_type) as exercise_types
                FROM exercises
            """))
            
            stats = result.fetchone()
            
            # Get breakdown by exercise type
            type_result = session.execute(text("""
                SELECT exercise_type, COUNT(*) as count
                FROM exercises
                GROUP BY exercise_type
                ORDER BY count DESC
            """))
            
            type_breakdown = {row.exercise_type: row.count for row in type_result}
            
            return {
                'total_exercises': stats.total_exercises,
                'source_languages': stats.source_languages,
                'target_languages': stats.target_languages,
                'difficulty_levels': stats.difficulty_levels,
                'exercise_types': stats.exercise_types,
                'type_breakdown': type_breakdown
            }
            
        except Exception as e:
            logger.error(f"Error getting statistics: {e}")
            return {}
        finally:
            session.close()
    
    def _generate_verification_hash(self, exercise_data: Dict) -> str:
        """Generate verification hash to prevent duplicates.
        
        Args:
            exercise_data: Exercise data dictionary
            
        Returns:
            Hash string
        """
        import hashlib
        
        # Create hash from key fields
        hash_input = f"{exercise_data.get('source_lang')}{exercise_data.get('target_lang')}"
        hash_input += f"{exercise_data.get('difficulty_level')}{exercise_data.get('exercise_type')}"
        hash_input += f"{exercise_data.get('exercise_input')[:100]}"  # First 100 chars of input
        
        return hashlib.md5(hash_input.encode()).hexdigest()

# ============================================================================
# CONVENIENCE FUNCTIONS
# ============================================================================

def save_exercise_from_orchestrator(exercise_data, curriculum_combo_id: str) -> Optional[str]:
    """Save exercise from orchestrator result.
    
    Args:
        exercise_data: GeneratedExercise from orchestrator
        curriculum_combo_id: Curriculum combination ID
        
    Returns:
        Exercise ID if successful
    """
    repo = ExerciseRepository()
    
    # Convert to dict format
    exercise_dict = {
        'source_lang': exercise_data.source_lang,
        'target_lang': exercise_data.target_lang,
        'difficulty_level': exercise_data.difficulty_level,
        'exercise_type': exercise_data.exercise_type_id,
        'theory': exercise_data.theory,
        'exercise_introduction': exercise_data.exercise_introduction,
        'exercise_input': exercise_data.exercise_input,
        'expected_output': exercise_data.expected_output,
        'topic': exercise_data.topic
    }
    
    return repo.save_generated_exercise(exercise_dict, curriculum_combo_id)

if __name__ == "__main__":
    # Demo the exercise repository
    logging.basicConfig(level=logging.INFO)
    
    print("ðŸŽ“ EXERCISE REPOSITORY DEMO")
    print("=" * 60)
    
    repo = ExerciseRepository()
    
    # Create table
    repo.create_exercises_table()
    
    # Get statistics
    stats = repo.get_exercise_statistics()
    print(f"ðŸ“Š Exercise Statistics:")
    print(f"   Total exercises: {stats.get('total_exercises', 0)}")
    print(f"   Source languages: {stats.get('source_languages', 0)}")
    print(f"   Target languages: {stats.get('target_languages', 0)}")
    print(f"   Exercise types: {stats.get('exercise_types', 0)}")
    
    print("\nâœ… Exercise repository demo completed!")
